fn main() {
    println!("Hello, world!");
}

// 变量对其管理的内存拥有所有权, 这个所有权不仅可以被转移(move), 还可以被借用(borrow)
// 借用指针也可以被称为"引用"

// &mut: mut修饰的是借用指针&
/*
!借用指针的规则
* 借用指针不能比它指向的变量存在的时间更长
* &mut型指针只能只想本身具有mut修饰的变量, 对于只读变量, 不可以有&mut型借用
* &mut型借用指针存在的时候, 被借用的变量本身会处于冻结状态
* 如果只有&型借用指针, 那么能同时存在多个, 如果存在&mut型借用指针, 那么只能存在一个
* 借用指针只能临时地借用对这个变量读或写的权限, 没有义务管理这个变量的生命周期
*/

#[test]
fn test1() {
    let mut x = 1_i32;
    let p = &mut x;
    //x = 2; x已经被借用了,x会被冻结
    println!("{:?}", p);
}

// 如果生命周期'a比'b更长或相等, 则记为'a: 'b
// 'static是一个特殊的生命周期. 代表的是这个程序从开始到结束的整个阶段, 比其他任何生命周期都长
struct T {
    data: i32,
}
#[allow(unused)]
fn test2<'a, 'b>(arg: &'a T) -> &'b i32
where
    'a: 'b,
{
    &arg.data
}

struct Today<'a> {
    data: &'a i32,
}

#[allow(unused)]
fn test3<'a>(arg: &'a Today) -> &'a i32 {
    &arg.data
}
// 如果自定义类型中有成员包含生命周期参数, 那么这个自定义类型也必须有生命周期参数
// impl后面的't是用来声明生命周期参数的, 后面的't是在类型中使用的
impl<'t> Today<'t> {}

// 生命周期标记可以省略, 但是有一些规则
