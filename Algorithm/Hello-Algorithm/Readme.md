## 复杂度分析
- 迭代: 是一种重复执行某个任务的控制结构. 再跌贷中, 程序会在满足一定的条件下重复执行某段代码, 直到这个条件不再满足.
  - `for循环`
  - `while循环`
  - `嵌套循环`
- 递归: 是一种算法策略, 通过函数调用自身来解决问题.
  - 递: 程序不断深入地调用自身, 通常传入更小或更简化的参数, 直到达到"控制条件".
  - 归: 触发"终止条件"后, 程序从最深层的递归函数开始逐层返回, 汇聚每一层的结果.
- 递归: 自上而下地解决问题. 将原本问题分解为更小的子问题, 这些子问题和原问题具有相同的形式.
  - 递归通常比迭代更加耗费内存空间. 因为每次调用自身都会开辟新的函数分配内存.
  - 普通递归
    - 当函数返回到上一层级的函数后, 需要继续执行代码, 因此系统需要保存上一层调用的上下文.
    - 求和操作是在"归"的过程中执行的, 每层返回后都要再执行一次求和操作.
  - 尾递归 
    - 递归调用是函数返回前的最后一个操作, 这意味着函数返回上一层级后, 无需继续执行其他操作, 因此系统无需保存上一层函数的上下文.
    - 求和操作在"递"的过程中执行, "归"的过程只需层层返回
- 迭代: 自下而上地解决问题. 从最基础的步骤开始, 然后不断重复或累加这些步骤, 直到任务完成.
```go
package main
// 普通递归
func getSum1(n int) int {
	if n == 1 {
		return 1
    }
	// 递: 递归调用, res的值需要一层一层深入下去才能得到
	res := getSum1(n-1)
	// 归: 返回结果
	return n + res
}

// 尾递归
func getSum2(n, res int) int {
  if n == 0 {
	  return res
  }
  // 尾递归调用, 当前函数已经结束然后进行到下一层, n-1, res+n的值都是确定的
  return getSum2(n-1, res+n)
}
```

### 时间复杂度
- 统计算法的运行时间不合理也不现实.
- 使用函数渐近上界, 通过`f(n)->O(f(n))`
- O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(2n) < O(n!)
- 常数阶 < 对数阶 < 线性阶 < 线性对数阶 < 平方阶 < 指数阶 < 阶乘阶
- 最差时间复杂度, 最佳时间复杂度, 平均时间复杂度
### 空间复杂度
- 算法在运行过程中使用的内存空间主要包括以下几种
  - 输入空间: 用于存储算法的输入数据
  - 暂存空间: 用于存储算法在运行过程中的变量, 对象, 函数上下文等数据
    - 暂存数据
    - 栈帧空间
    - 指令空间
  - 输出空间: 用于存储算法的输出数据
- 只关注最差空间复杂度
- O(1) < O(logn) < O(n) < O(n2) < O(2n)
- 常数阶 < 对数阶 < 线性阶 < 平方阶 < 指数阶
- 指数阶常见于二叉树, 平方阶常见于矩阵和图, 线性阶常见于递归, 数组, 链表, 栈, 队列等元素数量与n成正比的, 对数阶常见于分支算法(归并排序)